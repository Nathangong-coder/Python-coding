from flask import Flask, render_template, request, jsonify, session
import requests
import json
from datetime import datetime
import os
import uuid

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'your-secret-key-change-this')

# Store chat sessions in memory (in production, use a database)
chat_sessions = {}

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/chat', methods=['POST'])
def chat():
    try:
        data = request.json
        message = data.get('message', '').strip()
        api_key = data.get('api_key', '').strip()
        session_id = data.get('session_id')
        
        if not message or not api_key:
            return jsonify({'error': 'Message and API key are required'}), 400
        
        # Create new session if none exists
        if not session_id:
            session_id = str(uuid.uuid4())
            chat_sessions[session_id] = []
        
        # Get or create chat history
        if session_id not in chat_sessions:
            chat_sessions[session_id] = []
        
        chat_history = chat_sessions[session_id]
        
        # Add user message to history
        user_message = {
            'role': 'user',
            'content': message,
            'timestamp': datetime.now().isoformat()
        }
        chat_history.append(user_message)
        
        # Prepare messages for DeepSeek API
        api_messages = [{'role': msg['role'], 'content': msg['content']} 
                       for msg in chat_history if msg['role'] in ['user', 'assistant']]
        
        # Call DeepSeek API
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        
        payload = {
            'model': 'deepseek-chat',
            'messages': api_messages,
            'temperature': 0.7,
            'max_tokens': 2000
        }
        
        response = requests.post(
            'https://api.deepseek.com/v1/chat/completions',
            headers=headers,
            json=payload,
            timeout=30
        )
        
        if response.status_code != 200:
            error_msg = f"API request failed with status {response.status_code}"
            if response.text:
                error_msg += f": {response.text}"
            return jsonify({'error': error_msg}), 400
        
        response_data = response.json()
        
        # Extract assistant response
        assistant_content = response_data['choices'][0]['message']['content']
        
        # Add assistant message to history
        assistant_message = {
            'role': 'assistant',
            'content': assistant_content,
            'timestamp': datetime.now().isoformat()
        }
        chat_history.append(assistant_message)
        
        # Update session
        chat_sessions[session_id] = chat_history
        
        return jsonify({
            'response': assistant_content,
            'session_id': session_id,
            'chat_history': chat_history
        })
        
    except requests.exceptions.RequestException as e:
        return jsonify({'error': f'Network error: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Server error: {str(e)}'}), 500

@app.route('/api/clear-chat', methods=['POST'])
def clear_chat():
    try:
        data = request.json
        session_id = data.get('session_id')
        
        if session_id and session_id in chat_sessions:
            chat_sessions[session_id] = []
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/get-history', methods=['POST'])
def get_history():
    try:
        data = request.json
        session_id = data.get('session_id')
        
        if session_id and session_id in chat_sessions:
            return jsonify({'chat_history': chat_sessions[session_id]})
        else:
            return jsonify({'chat_history': []})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)